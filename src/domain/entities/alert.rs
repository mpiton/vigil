use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::domain::value_objects::action_risk::ActionRisk;
use crate::domain::value_objects::severity::Severity;

/// An alert generated by a rule when an anomaly is detected
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Alert {
    pub timestamp: DateTime<Utc>,
    pub severity: Severity,
    pub rule: String,
    pub title: String,
    pub details: String,
    pub suggested_actions: Vec<SuggestedAction>,
}

/// A suggested remediation action
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct SuggestedAction {
    pub description: String,
    pub command: String,
    pub risk: ActionRisk,
}

#[cfg(test)]
#[allow(clippy::expect_used)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn alert_serde_roundtrip() {
        let alert = Alert {
            timestamp: Utc::now(),
            severity: Severity::High,
            rule: "ram_critical".to_string(),
            title: "High memory usage".to_string(),
            details: "RAM at 95%".to_string(),
            suggested_actions: vec![SuggestedAction {
                description: "Kill heavy process".to_string(),
                command: "kill -9 1234".to_string(),
                risk: ActionRisk::Dangerous,
            }],
        };
        let json = serde_json::to_string(&alert).expect("serialize");
        let deserialized: Alert = serde_json::from_str(&json).expect("deserialize");
        assert_eq!(deserialized.severity, Severity::High);
        assert_eq!(deserialized.suggested_actions.len(), 1);
        assert_eq!(
            deserialized.suggested_actions[0].risk,
            ActionRisk::Dangerous
        );
    }
}
