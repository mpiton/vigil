# Vigil â€” Clean Architecture Structure

## Principes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation                         â”‚
â”‚                  (CLI, TUI, API)                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚              Application                      â”‚    â”‚
â”‚    â”‚          (Use Cases, Services)                 â”‚    â”‚
â”‚    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚    â”‚    â”‚            Domain                    â”‚    â”‚    â”‚
â”‚    â”‚    â”‚    (Entities, Traits, Rules)          â”‚    â”‚    â”‚
â”‚    â”‚    â”‚       âŸµ AUCUNE dÃ©pendance âŸ¶         â”‚    â”‚    â”‚
â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                    Infrastructure                       â”‚
â”‚        (OS, DB, API externe, Notifications)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ¨gle d'or : les dÃ©pendances pointent vers l'intÃ©rieur.
Le Domain ne connaÃ®t RIEN des couches extÃ©rieures.
```

## Structure

```
vigil/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ ARCHITECTURE.md
â”œâ”€â”€ config.default.toml              # Config de rÃ©fÃ©rence documentÃ©e
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                      # Point d'entrÃ©e, wiring DI, bootstrap
â”‚   â”œâ”€â”€ lib.rs                       # Re-exports publics pour tests/lib usage
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/                      # ğŸŸ¢ CÅ’UR â€” ZÃ©ro dÃ©pendance externe
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ entities/                # Structures de donnÃ©es mÃ©tier
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ snapshot.rs          # SystemSnapshot, MemoryInfo, CpuInfo
â”‚   â”‚   â”‚   â”œâ”€â”€ process.rs           # ProcessInfo, ProcessState
â”‚   â”‚   â”‚   â”œâ”€â”€ disk.rs              # DiskInfo
â”‚   â”‚   â”‚   â”œâ”€â”€ journal.rs           # JournalEntry
â”‚   â”‚   â”‚   â””â”€â”€ alert.rs             # Alert, Severity, SuggestedAction
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ rules/                   # RÃ¨gles de dÃ©tection (logique pure)
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs               # Trait Rule + RuleEngine
â”‚   â”‚   â”‚   â”œâ”€â”€ ram.rs               # RamWarningRule, RamCriticalRule
â”‚   â”‚   â”‚   â”œâ”€â”€ cpu.rs               # CpuOverloadRule
â”‚   â”‚   â”‚   â”œâ”€â”€ swap.rs              # SwapWarningRule
â”‚   â”‚   â”‚   â”œâ”€â”€ disk.rs              # DiskSpaceRule
â”‚   â”‚   â”‚   â”œâ”€â”€ zombie.rs            # ZombieProcessRule
â”‚   â”‚   â”‚   â”œâ”€â”€ duplicates.rs        # DuplicateProcessRule (cas MCP)
â”‚   â”‚   â”‚   â”œâ”€â”€ orphans.rs           # OrphanDevProcessRule
â”‚   â”‚   â”‚   â””â”€â”€ oom.rs               # OomKillerRule
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ports/                   # Traits (interfaces) â€” contrats
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ collector.rs         # trait SystemCollector
â”‚   â”‚   â”‚   â”œâ”€â”€ analyzer.rs          # trait AiAnalyzer
â”‚   â”‚   â”‚   â”œâ”€â”€ notifier.rs          # trait Notifier
â”‚   â”‚   â”‚   â”œâ”€â”€ store.rs             # trait AlertStore, SnapshotStore
â”‚   â”‚   â”‚   â””â”€â”€ process_manager.rs   # trait ProcessManager (kill, signal)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ value_objects/           # Types valeur immuables
â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚   â”‚       â”œâ”€â”€ severity.rs          # Severity (Low..Critical)
â”‚   â”‚       â”œâ”€â”€ action_risk.rs       # ActionRisk (Safe, Moderate, Dangerous)
â”‚   â”‚       â”œâ”€â”€ thresholds.rs        # ThresholdSet (seuils typÃ©s)
â”‚   â”‚       â””â”€â”€ operation_mode.rs    # OperationMode (Observe, Suggest, Auto)
â”‚   â”‚
â”‚   â”œâ”€â”€ application/                 # ğŸ”µ ORCHESTRATION â€” Use cases
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/                # Services applicatifs
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ monitor.rs           # MonitorService â€” boucle collectâ†’analyzeâ†’notify
â”‚   â”‚   â”‚   â”œâ”€â”€ scanner.rs           # ScanService â€” one-shot scan
â”‚   â”‚   â”‚   â”œâ”€â”€ explainer.rs         # ExplainService â€” explain un PID via IA
â”‚   â”‚   â”‚   â””â”€â”€ killer.rs            # KillService â€” kill avec log et confirmation
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ dto/                     # Data Transfer Objects (entre couches)
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ scan_result.rs       # ScanResult (snapshot + alerts + ai_diagnostic)
â”‚   â”‚   â”‚   â”œâ”€â”€ status_report.rs     # StatusReport (pour affichage)
â”‚   â”‚   â”‚   â””â”€â”€ ai_request.rs        # AiAnalysisRequest, AiDiagnostic
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ config.rs               # AppConfig (validation, defaults, chargement)
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/              # ğŸŸ  ADAPTATEURS EXTERNES
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ collectors/              # ImplÃ©mentations de SystemCollector
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ sysinfo_collector.rs # Via crate sysinfo (RAM, CPU, processus)
â”‚   â”‚   â”‚   â”œâ”€â”€ procfs_collector.rs  # Via /proc pour donnÃ©es dÃ©taillÃ©es
â”‚   â”‚   â”‚   â”œâ”€â”€ disk_collector.rs    # Espace disque via statvfs
â”‚   â”‚   â”‚   â”œâ”€â”€ journal_collector.rs # Lecture journald via journalctl
â”‚   â”‚   â”‚   â”œâ”€â”€ gpu_collector.rs     # NVIDIA via nvml-wrapper (optionnel)
â”‚   â”‚   â”‚   â””â”€â”€ composite.rs         # CompositeCollector (agrÃ¨ge tous les collectors)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ai/                      # ImplÃ©mentations de AiAnalyzer
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ claude.rs            # ClaudeAnalyzer (API Anthropic)
â”‚   â”‚   â”‚   â”œâ”€â”€ prompt_builder.rs    # Construction des prompts
â”‚   â”‚   â”‚   â””â”€â”€ noop.rs              # NoopAnalyzer (quand IA dÃ©sactivÃ©e)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ notifications/           # ImplÃ©mentations de Notifier
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ terminal.rs          # Sortie terminal colorÃ©e (ANSI)
â”‚   â”‚   â”‚   â”œâ”€â”€ desktop.rs           # notify-rust (freedesktop)
â”‚   â”‚   â”‚   â”œâ”€â”€ log_file.rs          # JSON append dans fichier
â”‚   â”‚   â”‚   â”œâ”€â”€ webhook.rs           # HTTP POST (Slack, Discord)
â”‚   â”‚   â”‚   â””â”€â”€ composite.rs         # CompositeNotifier (fan-out)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ persistence/             # ImplÃ©mentations de Store
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ sqlite_store.rs      # SQLite via rusqlite
â”‚   â”‚   â”‚   â”œâ”€â”€ migrations.rs        # SchÃ©ma et migrations DB
â”‚   â”‚   â”‚   â””â”€â”€ in_memory_store.rs   # Pour tests
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ os/                      # Interactions systÃ¨me
â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚   â”‚       â”œâ”€â”€ process_manager.rs   # Kill/signal via nix
â”‚   â”‚       â””â”€â”€ system_info.rs       # Helpers OS (uptime, hostname, etc.)
â”‚   â”‚
â”‚   â””â”€â”€ presentation/                # ğŸŸ£ INTERFACES UTILISATEUR
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚
â”‚       â”œâ”€â”€ cli/                     # Interface ligne de commande
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ app.rs               # DÃ©finition clap (Cli, Commands)
â”‚       â”‚   â”œâ”€â”€ commands/
â”‚       â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚   â”œâ”€â”€ daemon.rs        # vigil (daemon)
â”‚       â”‚   â”‚   â”œâ”€â”€ status.rs        # vigil status
â”‚       â”‚   â”‚   â”œâ”€â”€ scan.rs          # vigil scan [--ai]
â”‚       â”‚   â”‚   â”œâ”€â”€ explain.rs       # vigil explain <pid>
â”‚       â”‚   â”‚   â”œâ”€â”€ kill.rs          # vigil kill <pid>
â”‚       â”‚   â”‚   â””â”€â”€ config.rs        # vigil config [--edit]
â”‚       â”‚   â””â”€â”€ formatters/
â”‚       â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚       â”œâ”€â”€ status_fmt.rs    # Formatage du status (barres, couleurs)
â”‚       â”‚       â”œâ”€â”€ alert_fmt.rs     # Formatage des alertes
â”‚       â”‚       â””â”€â”€ table_fmt.rs     # Formatage en tableaux
â”‚       â”‚
â”‚       â””â”€â”€ tui/                     # Interface terminal interactive (futur)
â”‚           â”œâ”€â”€ mod.rs
â”‚           â”œâ”€â”€ app.rs               # Ã‰tat et boucle ratatui
â”‚           â”œâ”€â”€ widgets/
â”‚           â”‚   â”œâ”€â”€ mod.rs
â”‚           â”‚   â”œâ”€â”€ dashboard.rs     # Vue principale
â”‚           â”‚   â”œâ”€â”€ process_list.rs  # Liste de processus
â”‚           â”‚   â””â”€â”€ alert_panel.rs   # Panneau d'alertes
â”‚           â””â”€â”€ event.rs             # Gestion des Ã©vÃ©nements clavier
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ integration/
    â”‚   â”œâ”€â”€ scan_test.rs             # Test scan end-to-end
    â”‚   â”œâ”€â”€ rules_test.rs            # Test des rÃ¨gles avec snapshots mockÃ©s
    â”‚   â””â”€â”€ ai_test.rs               # Test intÃ©gration IA (avec mock HTTP)
    â”‚
    â””â”€â”€ fixtures/
        â”œâ”€â”€ snapshot_normal.json     # Snapshot systÃ¨me sain
        â”œâ”€â”€ snapshot_ram_critical.json
        â”œâ”€â”€ snapshot_mcp_zombies.json # Cas MCP Python en boucle
        â””â”€â”€ snapshot_oom.json
```

## ResponsabilitÃ©s par couche

### ğŸŸ¢ Domain â€” Le cÅ“ur pur

**ZÃ©ro `use` externe** (pas de tokio, sysinfo, reqwest, etc.).
Uniquement `std`, `serde` (pour dÃ©river Serialize/Deserialize), `chrono`, `thiserror`.

```rust
// domain/ports/collector.rs
use crate::domain::entities::snapshot::SystemSnapshot;

pub trait SystemCollector: Send + Sync {
    fn collect(&mut self) -> Result<SystemSnapshot, CollectionError>;
}

// domain/ports/analyzer.rs
use crate::domain::entities::{alert::Alert, snapshot::SystemSnapshot};
use crate::application::dto::ai_request::AiDiagnostic;

#[async_trait::async_trait]
pub trait AiAnalyzer: Send + Sync {
    async fn analyze(
        &mut self,
        snapshot: &SystemSnapshot,
        alerts: &[Alert],
    ) -> Result<Option<AiDiagnostic>, AnalysisError>;
}

// domain/ports/notifier.rs
use crate::domain::entities::alert::Alert;

pub trait Notifier: Send + Sync {
    fn notify(&self, alert: &Alert) -> Result<(), NotificationError>;
}

// domain/ports/store.rs
use crate::domain::entities::{alert::Alert, snapshot::SystemSnapshot};

pub trait AlertStore: Send + Sync {
    fn save_alert(&self, alert: &Alert) -> Result<(), StoreError>;
    fn recent_alerts(&self, limit: usize) -> Result<Vec<Alert>, StoreError>;
}

pub trait SnapshotStore: Send + Sync {
    fn save_snapshot(&self, snapshot: &SystemSnapshot) -> Result<(), StoreError>;
}
```

```rust
// domain/rules/mod.rs â€” Chaque rÃ¨gle est une fonction pure
use crate::domain::entities::{alert::Alert, snapshot::SystemSnapshot};
use crate::domain::value_objects::thresholds::ThresholdSet;

pub trait Rule: Send + Sync {
    fn name(&self) -> &str;
    fn evaluate(&self, snapshot: &SystemSnapshot, thresholds: &ThresholdSet) -> Vec<Alert>;
}

pub struct RuleEngine {
    rules: Vec<Box<dyn Rule>>,
}

impl RuleEngine {
    pub fn new(rules: Vec<Box<dyn Rule>>) -> Self {
        Self { rules }
    }

    pub fn analyze(&self, snapshot: &SystemSnapshot, thresholds: &ThresholdSet) -> Vec<Alert> {
        let mut alerts: Vec<Alert> = self.rules
            .iter()
            .flat_map(|rule| rule.evaluate(snapshot, thresholds))
            .collect();
        alerts.sort_by(|a, b| b.severity.cmp(&a.severity));
        alerts
    }
}
```

```rust
// domain/rules/duplicates.rs â€” Exemple de rÃ¨gle pure
pub struct DuplicateProcessRule;

impl Rule for DuplicateProcessRule {
    fn name(&self) -> &str { "duplicate_processes" }

    fn evaluate(&self, snapshot: &SystemSnapshot, thresholds: &ThresholdSet) -> Vec<Alert> {
        // Logique pure : grouper, compter, alerter
        // Aucun accÃ¨s systÃ¨me, aucun I/O
    }
}
```

### ğŸ”µ Application â€” Orchestration

DÃ©pend du Domain (traits + entities). Ne connaÃ®t PAS les implÃ©mentations concrÃ¨tes.
ReÃ§oit les dÃ©pendances par injection (constructeur).

```rust
// application/services/monitor.rs
pub struct MonitorService<C, A, N, S>
where
    C: SystemCollector,
    A: AiAnalyzer,
    N: Notifier,
    S: AlertStore,
{
    collector: C,
    ai: A,
    notifier: N,
    store: S,
    rule_engine: RuleEngine,
    config: AppConfig,
}

impl<C, A, N, S> MonitorService<C, A, N, S>
where
    C: SystemCollector,
    A: AiAnalyzer,
    N: Notifier,
    S: AlertStore,
{
    pub async fn tick(&mut self) -> Result<()> {
        let snapshot = self.collector.collect()?;
        let alerts = self.rule_engine.analyze(&snapshot, &self.config.thresholds);

        for alert in &alerts {
            self.notifier.notify(alert)?;
            self.store.save_alert(alert)?;
        }

        if self.should_invoke_ai(&alerts) {
            if let Some(diagnostic) = self.ai.analyze(&snapshot, &alerts).await? {
                self.handle_ai_diagnostic(&diagnostic)?;
            }
        }

        Ok(())
    }
}
```

### ğŸŸ  Infrastructure â€” Le monde rÃ©el

ImplÃ©mente les traits du Domain. Contient TOUTES les dÃ©pendances externes.

```rust
// infrastructure/collectors/sysinfo_collector.rs
use sysinfo::System;
use crate::domain::ports::collector::SystemCollector;

pub struct SysinfoCollector {
    sys: System,
}

impl SystemCollector for SysinfoCollector {
    fn collect(&mut self) -> Result<SystemSnapshot, CollectionError> {
        self.sys.refresh_all();
        // ... conversion sysinfo â†’ domain entities
    }
}

// infrastructure/ai/claude.rs
use reqwest::Client;
use crate::domain::ports::analyzer::AiAnalyzer;

pub struct ClaudeAnalyzer {
    client: Client,
    model: String,
    api_key: String,
}

#[async_trait::async_trait]
impl AiAnalyzer for ClaudeAnalyzer {
    async fn analyze(&mut self, snapshot: &SystemSnapshot, alerts: &[Alert])
        -> Result<Option<AiDiagnostic>, AnalysisError>
    {
        // HTTP call to Anthropic API
    }
}

// infrastructure/ai/noop.rs
pub struct NoopAnalyzer;

#[async_trait::async_trait]
impl AiAnalyzer for NoopAnalyzer {
    async fn analyze(&mut self, _: &SystemSnapshot, _: &[Alert])
        -> Result<Option<AiDiagnostic>, AnalysisError>
    {
        Ok(None) // IA dÃ©sactivÃ©e
    }
}
```

### ğŸŸ£ Presentation â€” Interface utilisateur

DÃ©pend de Application (services, DTOs). Convertit les DTOs en affichage.

```rust
// presentation/cli/commands/scan.rs
pub async fn execute(service: &mut ScanService<...>, args: &ScanArgs) -> Result<()> {
    let result = service.run(args.use_ai).await?;

    if args.json {
        println!("{}", serde_json::to_string_pretty(&result)?);
    } else {
        AlertFormatter::print_alerts(&result.alerts);
        if let Some(diag) = &result.ai_diagnostic {
            AiFormatter::print_diagnostic(diag);
        }
    }

    Ok(())
}
```

### main.rs â€” Le cÃ¢blage (Composition Root)

```rust
// main.rs â€” Seul endroit qui connaÃ®t TOUTES les implÃ©mentations concrÃ¨tes
#[tokio::main]
async fn main() -> Result<()> {
    let config = AppConfig::load()?;

    // Injection de dÃ©pendances manuelle (pas besoin de framework DI en Rust)
    let collector = SysinfoCollector::new();
    let notifier = CompositeNotifier::from_config(&config.notifications);
    let store = SqliteStore::open(&config.database_path)?;

    let ai: Box<dyn AiAnalyzer> = if config.ai.enabled {
        Box::new(ClaudeAnalyzer::new(&config.ai)?)
    } else {
        Box::new(NoopAnalyzer)
    };

    let rules: Vec<Box<dyn Rule>> = vec![
        Box::new(RamCriticalRule),
        Box::new(RamWarningRule),
        Box::new(SwapWarningRule),
        Box::new(CpuOverloadRule),
        Box::new(ZombieProcessRule),
        Box::new(DuplicateProcessRule),
        Box::new(OrphanDevProcessRule),
        Box::new(DiskSpaceRule),
        Box::new(OomKillerRule),
    ];
    let rule_engine = RuleEngine::new(rules);

    // Dispatch CLI command â†’ service
    match cli.command {
        Commands::Daemon { .. } => {
            let mut service = MonitorService::new(
                collector, ai, notifier, store, rule_engine, config
            );
            service.run_loop().await
        }
        Commands::Scan { ai, json } => { /* ... */ }
        // ...
    }
}
```

## Flux de dÃ©pendances

```
main.rs (composition root)
   â”‚
   â”œâ”€â”€ presentation/cli â”€â”€â†’ application/services â”€â”€â†’ domain/ports (traits)
   â”‚                                                      â†‘
   â””â”€â”€ infrastructure/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         (implÃ©mente les traits)
```

**Jamais** :
- âŒ domain â†’ infrastructure
- âŒ domain â†’ presentation
- âŒ application â†’ infrastructure (directement)
- âŒ presentation â†’ infrastructure (directement)

**Toujours** :
- âœ… infrastructure â†’ domain (implÃ©mente les ports)
- âœ… application â†’ domain (utilise les ports/entities)
- âœ… presentation â†’ application (appelle les services)
- âœ… main.rs â†’ tout (cÃ¢blage unique)

## TestabilitÃ©

GrÃ¢ce aux traits, chaque couche se teste indÃ©pendamment :

```
tests/
â”œâ”€â”€ integration/           # Tests end-to-end avec vrais composants
â”œâ”€â”€ fixtures/              # Snapshots JSON pour alimenter les tests
```

```rust
// Test unitaire d'une rÃ¨gle (logique pure, pas de mock)
#[test]
fn duplicate_rule_detects_mcp_storm() {
    let snapshot = load_fixture("snapshot_mcp_zombies.json");
    let thresholds = ThresholdSet::default();
    let rule = DuplicateProcessRule;

    let alerts = rule.evaluate(&snapshot, &thresholds);

    assert_eq!(alerts.len(), 1);
    assert_eq!(alerts[0].severity, Severity::High);
    assert!(alerts[0].title.contains("python"));
}

// Test d'un service avec mocks
#[tokio::test]
async fn monitor_notifies_on_critical_ram() {
    let collector = MockCollector::with_snapshot(critical_ram_snapshot());
    let notifier = MockNotifier::new();
    let store = InMemoryStore::new();
    let ai = NoopAnalyzer;

    let mut service = MonitorService::new(collector, ai, notifier.clone(), store, ...);
    service.tick().await.unwrap();

    assert_eq!(notifier.alerts_sent(), 1);
}
```
