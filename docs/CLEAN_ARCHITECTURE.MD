# Vigil â€” Clean Architecture Structure

## Principles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation                         â”‚
â”‚                  (CLI, TUI, API)                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚              Application                      â”‚    â”‚
â”‚    â”‚          (Use Cases, Services)                 â”‚    â”‚
â”‚    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚    â”‚    â”‚            Domain                    â”‚    â”‚    â”‚
â”‚    â”‚    â”‚    (Entities, Traits, Rules)          â”‚    â”‚    â”‚
â”‚    â”‚    â”‚       âŸµ NO dependencies âŸ¶           â”‚    â”‚    â”‚
â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                    Infrastructure                       â”‚
â”‚        (OS, DB, external API, Notifications)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Golden rule: dependencies point inward.
The Domain knows NOTHING about outer layers.
```

## Structure

```
vigil/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ ARCHITECTURE.md
â”œâ”€â”€ config.default.toml              # Documented reference config
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                      # Entry point, DI wiring, bootstrap
â”‚   â”œâ”€â”€ lib.rs                       # Public re-exports for tests/lib usage
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/                      # ğŸŸ¢ CORE â€” Zero external dependencies
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ entities/                # Business data structures
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ snapshot.rs          # SystemSnapshot, MemoryInfo, CpuInfo
â”‚   â”‚   â”‚   â”œâ”€â”€ process.rs           # ProcessInfo, ProcessState
â”‚   â”‚   â”‚   â”œâ”€â”€ disk.rs              # DiskInfo
â”‚   â”‚   â”‚   â”œâ”€â”€ journal.rs           # JournalEntry
â”‚   â”‚   â”‚   â””â”€â”€ alert.rs             # Alert, Severity, SuggestedAction
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ rules/                   # Detection rules (pure logic)
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs               # Trait Rule + RuleEngine
â”‚   â”‚   â”‚   â”œâ”€â”€ ram.rs               # RamWarningRule, RamCriticalRule
â”‚   â”‚   â”‚   â”œâ”€â”€ cpu.rs               # CpuOverloadRule
â”‚   â”‚   â”‚   â”œâ”€â”€ swap.rs              # SwapWarningRule
â”‚   â”‚   â”‚   â”œâ”€â”€ disk.rs              # DiskSpaceRule
â”‚   â”‚   â”‚   â”œâ”€â”€ zombie.rs            # ZombieProcessRule
â”‚   â”‚   â”‚   â”œâ”€â”€ duplicates.rs        # DuplicateProcessRule (MCP case)
â”‚   â”‚   â”‚   â”œâ”€â”€ orphans.rs           # OrphanDevProcessRule
â”‚   â”‚   â”‚   â””â”€â”€ oom.rs               # OomKillerRule
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ports/                   # Traits (interfaces) â€” contracts
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ collector.rs         # trait SystemCollector
â”‚   â”‚   â”‚   â”œâ”€â”€ analyzer.rs          # trait AiAnalyzer
â”‚   â”‚   â”‚   â”œâ”€â”€ notifier.rs          # trait Notifier
â”‚   â”‚   â”‚   â”œâ”€â”€ store.rs             # trait AlertStore, SnapshotStore
â”‚   â”‚   â”‚   â””â”€â”€ process_manager.rs   # trait ProcessManager (kill, signal)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ value_objects/           # Immutable value types
â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚   â”‚       â”œâ”€â”€ severity.rs          # Severity (Low..Critical)
â”‚   â”‚       â”œâ”€â”€ action_risk.rs       # ActionRisk (Safe, Moderate, Dangerous)
â”‚   â”‚       â”œâ”€â”€ thresholds.rs        # ThresholdSet (typed thresholds)
â”‚   â”‚       â””â”€â”€ operation_mode.rs    # OperationMode (Observe, Suggest, Auto)
â”‚   â”‚
â”‚   â”œâ”€â”€ application/                 # ğŸ”µ ORCHESTRATION â€” Use cases
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/                # Application services
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ monitor.rs           # MonitorService â€” collectâ†’analyzeâ†’notify loop
â”‚   â”‚   â”‚   â”œâ”€â”€ scanner.rs           # ScanService â€” one-shot scan
â”‚   â”‚   â”‚   â”œâ”€â”€ explainer.rs         # ExplainService â€” explain a PID via AI
â”‚   â”‚   â”‚   â””â”€â”€ killer.rs            # KillService â€” kill with logging and confirmation
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ dto/                     # Data Transfer Objects (between layers)
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ scan_result.rs       # ScanResult (snapshot + alerts + ai_diagnostic)
â”‚   â”‚   â”‚   â”œâ”€â”€ status_report.rs     # StatusReport (for display)
â”‚   â”‚   â”‚   â””â”€â”€ ai_request.rs        # AiAnalysisRequest, AiDiagnostic
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ config.rs               # AppConfig (validation, defaults, loading)
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/              # ğŸŸ  EXTERNAL ADAPTERS
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ collectors/              # Implementations of SystemCollector
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ sysinfo_collector.rs # Via sysinfo crate (RAM, CPU, processes)
â”‚   â”‚   â”‚   â”œâ”€â”€ procfs_collector.rs  # Via /proc for detailed data
â”‚   â”‚   â”‚   â”œâ”€â”€ disk_collector.rs    # Disk space via statvfs
â”‚   â”‚   â”‚   â”œâ”€â”€ journal_collector.rs # journald reading via journalctl
â”‚   â”‚   â”‚   â”œâ”€â”€ gpu_collector.rs     # NVIDIA via nvml-wrapper (optional)
â”‚   â”‚   â”‚   â””â”€â”€ composite.rs         # CompositeCollector (aggregates all)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ai/                      # Implementations of AiAnalyzer
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ claude.rs            # ClaudeAnalyzer (Anthropic API)
â”‚   â”‚   â”‚   â”œâ”€â”€ prompt_builder.rs    # Prompt construction
â”‚   â”‚   â”‚   â””â”€â”€ noop.rs              # NoopAnalyzer (when AI disabled)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ notifications/           # Implementations of Notifier
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ terminal.rs          # Colored terminal output (ANSI)
â”‚   â”‚   â”‚   â”œâ”€â”€ desktop.rs           # notify-rust (freedesktop)
â”‚   â”‚   â”‚   â”œâ”€â”€ log_file.rs          # JSON append to file
â”‚   â”‚   â”‚   â”œâ”€â”€ webhook.rs           # HTTP POST (Slack, Discord)
â”‚   â”‚   â”‚   â””â”€â”€ composite.rs         # CompositeNotifier (fan-out)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ persistence/             # Implementations of Store
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ sqlite_store.rs      # SQLite via rusqlite
â”‚   â”‚   â”‚   â”œâ”€â”€ migrations.rs        # Schema and DB migrations
â”‚   â”‚   â”‚   â””â”€â”€ in_memory_store.rs   # For testing
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ os/                      # System interactions
â”‚   â”‚       â”œâ”€â”€ mod.rs
â”‚   â”‚       â”œâ”€â”€ process_manager.rs   # Kill/signal via nix
â”‚   â”‚       â””â”€â”€ system_info.rs       # OS helpers (uptime, hostname, etc.)
â”‚   â”‚
â”‚   â””â”€â”€ presentation/                # ğŸŸ£ USER INTERFACES
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚
â”‚       â”œâ”€â”€ cli/                     # Command-line interface
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ app.rs               # clap definition (Cli, Commands)
â”‚       â”‚   â”œâ”€â”€ commands/
â”‚       â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚   â”œâ”€â”€ daemon.rs        # vigil (daemon)
â”‚       â”‚   â”‚   â”œâ”€â”€ status.rs        # vigil status
â”‚       â”‚   â”‚   â”œâ”€â”€ scan.rs          # vigil scan [--ai]
â”‚       â”‚   â”‚   â”œâ”€â”€ explain.rs       # vigil explain <pid>
â”‚       â”‚   â”‚   â”œâ”€â”€ kill.rs          # vigil kill <pid>
â”‚       â”‚   â”‚   â””â”€â”€ config.rs        # vigil config [--edit]
â”‚       â”‚   â””â”€â”€ formatters/
â”‚       â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚       â”œâ”€â”€ status_fmt.rs    # Status formatting (bars, colors)
â”‚       â”‚       â”œâ”€â”€ alert_fmt.rs     # Alert formatting
â”‚       â”‚       â””â”€â”€ table_fmt.rs     # Table formatting
â”‚       â”‚
â”‚       â””â”€â”€ tui/                     # Interactive terminal interface (future)
â”‚           â”œâ”€â”€ mod.rs
â”‚           â”œâ”€â”€ app.rs               # State and ratatui loop
â”‚           â”œâ”€â”€ widgets/
â”‚           â”‚   â”œâ”€â”€ mod.rs
â”‚           â”‚   â”œâ”€â”€ dashboard.rs     # Main view
â”‚           â”‚   â”œâ”€â”€ process_list.rs  # Process list
â”‚           â”‚   â””â”€â”€ alert_panel.rs   # Alert panel
â”‚           â””â”€â”€ event.rs             # Keyboard event handling
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ integration/
    â”‚   â”œâ”€â”€ scan_test.rs             # End-to-end scan test
    â”‚   â”œâ”€â”€ rules_test.rs            # Rule tests with mocked snapshots
    â”‚   â””â”€â”€ ai_test.rs               # AI integration test (with HTTP mock)
    â”‚
    â””â”€â”€ fixtures/
        â”œâ”€â”€ snapshot_normal.json     # Healthy system snapshot
        â”œâ”€â”€ snapshot_ram_critical.json
        â”œâ”€â”€ snapshot_mcp_zombies.json # MCP Python in loop case
        â””â”€â”€ snapshot_oom.json
```

## Responsibilities per Layer

### ğŸŸ¢ Domain â€” The Pure Core

**Zero external `use`** (no tokio, sysinfo, reqwest, etc.).
Only `std`, `serde` (for Serialize/Deserialize derive), `chrono`, `thiserror`.

```rust
// domain/ports/collector.rs
use crate::domain::entities::snapshot::SystemSnapshot;

pub trait SystemCollector: Send + Sync {
    fn collect(&mut self) -> Result<SystemSnapshot, CollectionError>;
}

// domain/ports/analyzer.rs
use crate::domain::entities::{alert::Alert, snapshot::SystemSnapshot};
use crate::application::dto::ai_request::AiDiagnostic;

#[async_trait::async_trait]
pub trait AiAnalyzer: Send + Sync {
    async fn analyze(
        &mut self,
        snapshot: &SystemSnapshot,
        alerts: &[Alert],
    ) -> Result<Option<AiDiagnostic>, AnalysisError>;
}

// domain/ports/notifier.rs
use crate::domain::entities::alert::Alert;

pub trait Notifier: Send + Sync {
    fn notify(&self, alert: &Alert) -> Result<(), NotificationError>;
}

// domain/ports/store.rs
use crate::domain::entities::{alert::Alert, snapshot::SystemSnapshot};

pub trait AlertStore: Send + Sync {
    fn save_alert(&self, alert: &Alert) -> Result<(), StoreError>;
    fn recent_alerts(&self, limit: usize) -> Result<Vec<Alert>, StoreError>;
}

pub trait SnapshotStore: Send + Sync {
    fn save_snapshot(&self, snapshot: &SystemSnapshot) -> Result<(), StoreError>;
}
```

```rust
// domain/rules/mod.rs â€” Each rule is a pure function
use crate::domain::entities::{alert::Alert, snapshot::SystemSnapshot};
use crate::domain::value_objects::thresholds::ThresholdSet;

pub trait Rule: Send + Sync {
    fn name(&self) -> &str;
    fn evaluate(&self, snapshot: &SystemSnapshot, thresholds: &ThresholdSet) -> Vec<Alert>;
}

pub struct RuleEngine {
    rules: Vec<Box<dyn Rule>>,
}

impl RuleEngine {
    pub fn new(rules: Vec<Box<dyn Rule>>) -> Self {
        Self { rules }
    }

    pub fn analyze(&self, snapshot: &SystemSnapshot, thresholds: &ThresholdSet) -> Vec<Alert> {
        let mut alerts: Vec<Alert> = self.rules
            .iter()
            .flat_map(|rule| rule.evaluate(snapshot, thresholds))
            .collect();
        alerts.sort_by(|a, b| b.severity.cmp(&a.severity));
        alerts
    }
}
```

```rust
// domain/rules/duplicates.rs â€” Example of pure rule
pub struct DuplicateProcessRule;

impl Rule for DuplicateProcessRule {
    fn name(&self) -> &str { "duplicate_processes" }

    fn evaluate(&self, snapshot: &SystemSnapshot, thresholds: &ThresholdSet) -> Vec<Alert> {
        // Pure logic: group, count, alert
        // No system access, no I/O
    }
}
```

### ğŸ”µ Application â€” Orchestration

Depends on Domain (traits + entities). Does NOT know concrete implementations.
Receives dependencies via injection (constructor).

```rust
// application/services/monitor.rs
pub struct MonitorService<C, A, N, S>
where
    C: SystemCollector,
    A: AiAnalyzer,
    N: Notifier,
    S: AlertStore,
{
    collector: C,
    ai: A,
    notifier: N,
    store: S,
    rule_engine: RuleEngine,
    config: AppConfig,
}

impl<C, A, N, S> MonitorService<C, A, N, S>
where
    C: SystemCollector,
    A: AiAnalyzer,
    N: Notifier,
    S: AlertStore,
{
    pub async fn tick(&mut self) -> Result<()> {
        let snapshot = self.collector.collect()?;
        let alerts = self.rule_engine.analyze(&snapshot, &self.config.thresholds);

        for alert in &alerts {
            self.notifier.notify(alert)?;
            self.store.save_alert(alert)?;
        }

        if self.should_invoke_ai(&alerts) {
            if let Some(diagnostic) = self.ai.analyze(&snapshot, &alerts).await? {
                self.handle_ai_diagnostic(&diagnostic)?;
            }
        }

        Ok(())
    }
}
```

### ğŸŸ  Infrastructure â€” The Real World

Implements Domain traits. Contains ALL external dependencies.

```rust
// infrastructure/collectors/sysinfo_collector.rs
use sysinfo::System;
use crate::domain::ports::collector::SystemCollector;

pub struct SysinfoCollector {
    sys: System,
}

impl SystemCollector for SysinfoCollector {
    fn collect(&mut self) -> Result<SystemSnapshot, CollectionError> {
        self.sys.refresh_all();
        // ... conversion sysinfo â†’ domain entities
    }
}

// infrastructure/ai/claude.rs
use reqwest::Client;
use crate::domain::ports::analyzer::AiAnalyzer;

pub struct ClaudeAnalyzer {
    client: Client,
    model: String,
    api_key: String,
}

#[async_trait::async_trait]
impl AiAnalyzer for ClaudeAnalyzer {
    async fn analyze(&mut self, snapshot: &SystemSnapshot, alerts: &[Alert])
        -> Result<Option<AiDiagnostic>, AnalysisError>
    {
        // HTTP call to Anthropic API
    }
}

// infrastructure/ai/noop.rs
pub struct NoopAnalyzer;

#[async_trait::async_trait]
impl AiAnalyzer for NoopAnalyzer {
    async fn analyze(&mut self, _: &SystemSnapshot, _: &[Alert])
        -> Result<Option<AiDiagnostic>, AnalysisError>
    {
        Ok(None) // AI disabled
    }
}
```

### ğŸŸ£ Presentation â€” User Interface

Depends on Application (services, DTOs). Converts DTOs to display.

```rust
// presentation/cli/commands/scan.rs
pub async fn execute(service: &mut ScanService<...>, args: &ScanArgs) -> Result<()> {
    let result = service.run(args.use_ai).await?;

    if args.json {
        println!("{}", serde_json::to_string_pretty(&result)?);
    } else {
        AlertFormatter::print_alerts(&result.alerts);
        if let Some(diag) = &result.ai_diagnostic {
            AiFormatter::print_diagnostic(diag);
        }
    }

    Ok(())
}
```

### main.rs â€” The Wiring (Composition Root)

```rust
// main.rs â€” Only place that knows ALL concrete implementations
#[tokio::main]
async fn main() -> Result<()> {
    let config = AppConfig::load()?;

    // Manual dependency injection (no DI framework needed in Rust)
    let collector = SysinfoCollector::new();
    let notifier = CompositeNotifier::from_config(&config.notifications);
    let store = SqliteStore::open(&config.database_path)?;

    let ai: Box<dyn AiAnalyzer> = if config.ai.enabled {
        Box::new(ClaudeAnalyzer::new(&config.ai)?)
    } else {
        Box::new(NoopAnalyzer)
    };

    let rules: Vec<Box<dyn Rule>> = vec![
        Box::new(RamCriticalRule),
        Box::new(RamWarningRule),
        Box::new(SwapWarningRule),
        Box::new(CpuOverloadRule),
        Box::new(ZombieProcessRule),
        Box::new(DuplicateProcessRule),
        Box::new(OrphanDevProcessRule),
        Box::new(DiskSpaceRule),
        Box::new(OomKillerRule),
    ];
    let rule_engine = RuleEngine::new(rules);

    // Dispatch CLI command â†’ service
    match cli.command {
        Commands::Daemon { .. } => {
            let mut service = MonitorService::new(
                collector, ai, notifier, store, rule_engine, config
            );
            service.run_loop().await
        }
        Commands::Scan { ai, json } => { /* ... */ }
        // ...
    }
}
```

## Dependency Flow

```
main.rs (composition root)
   â”‚
   â”œâ”€â”€ presentation/cli â”€â”€â†’ application/services â”€â”€â†’ domain/ports (traits)
   â”‚                                                      â†‘
   â””â”€â”€ infrastructure/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         (implements traits)
```

**Never:**
- âŒ domain â†’ infrastructure
- âŒ domain â†’ presentation
- âŒ application â†’ infrastructure (directly)
- âŒ presentation â†’ infrastructure (directly)

**Always:**
- âœ… infrastructure â†’ domain (implements ports)
- âœ… application â†’ domain (uses ports/entities)
- âœ… presentation â†’ application (calls services)
- âœ… main.rs â†’ everything (unique wiring)

## Testability

Thanks to traits, each layer tests independently:

```
tests/
â”œâ”€â”€ integration/           # End-to-end tests with real components
â”œâ”€â”€ fixtures/              # JSON snapshots to feed tests
```

```rust
// Unit test of a rule (pure logic, no mock)
#[test]
fn duplicate_rule_detects_mcp_storm() {
    let snapshot = load_fixture("snapshot_mcp_zombies.json");
    let thresholds = ThresholdSet::default();
    let rule = DuplicateProcessRule;

    let alerts = rule.evaluate(&snapshot, &thresholds);

    assert_eq!(alerts.len(), 1);
    assert_eq!(alerts[0].severity, Severity::High);
    assert!(alerts[0].title.contains("python"));
}

// Test of a service with mocks
#[tokio::test]
async fn monitor_notifies_on_critical_ram() {
    let collector = MockCollector::with_snapshot(critical_ram_snapshot());
    let notifier = MockNotifier::new();
    let store = InMemoryStore::new();
    let ai = NoopAnalyzer;

    let mut service = MonitorService::new(collector, ai, notifier.clone(), store, ...);
    service.tick().await.unwrap();

    assert_eq!(notifier.alerts_sent(), 1);
}
```
